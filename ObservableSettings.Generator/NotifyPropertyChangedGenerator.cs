using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;
using Microsoft.CodeAnalysis.Text;
using ObservableSettings.Generator.Extensions;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;
using PropertyTuple = (Microsoft.CodeAnalysis.IPropertySymbol PropertySymbol, Microsoft.CodeAnalysis.SemanticModel);

namespace ObservableSettings.Generator;

[Generator]
public class NotifyPropertyChangedGenerator : IIncrementalGenerator
{
    private const string NotifyPropertyChangedWhenAttributeFullName = "ObservableSettings.NotifyPropertyChangedWhenAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var propertySymbols = context
            .ForAttributeWithMetadataNameAndOptions(
                NotifyPropertyChangedWhenAttributeFullName,
                predicate: (node, _) => node.IsValidPropertyDeclaration(),
                transform: (ctx, _) => (PropertySymbol: (IPropertySymbol)ctx.TargetSymbol, ctx.SemanticModel))
            .Where(ctx => ctx.PropertySymbol.ContainingType is not null);

        var compilationAndProperties = context.CompilationProvider.Combine(propertySymbols.Collect());

        context.RegisterSourceOutput(compilationAndProperties, (spc, source) =>
        {
            var compilation = source.Left;
            var ctx = source.Right;

            if (ctx.IsDefaultOrEmpty)
                return;

            foreach (var group in ctx.GroupBy<PropertyTuple, INamedTypeSymbol?>(p => p.PropertySymbol.ContainingType, SymbolEqualityComparer.Default))
            {
                var containingClass = group.Key;
                if (containingClass is null)
                {
                    continue;
                }

                var sourceCode = GenerateClassSource(compilation, containingClass, [.. group]);
                spc.AddSource($"{containingClass.ContainingNamespace.ToDisplayString()}.{containingClass.Name}.NotifyPropertyChangedWhen.g.cs",
                    SourceText.From(sourceCode, Encoding.UTF8));
            }
        });
    }

    private string GenerateClassSource(Compilation compilation, INamedTypeSymbol containingClass, ICollection<PropertyTuple> properties)
    {
        var namespaceDeclaration = NamespaceDeclaration(ParseName(containingClass.ContainingNamespace.ToDisplayString()));
        var classDeclaration = ClassDeclaration(containingClass.Name)
            .AddModifiers(Token(SyntaxKind.PartialKeyword))
            .AddMembers(GenerateContent(compilation, containingClass, properties));

        var complicationUnit = CompilationUnit()
            .AddMembers(namespaceDeclaration.AddMembers(classDeclaration))
            .WithLeadingTrivia(
                ParseLeadingTrivia("// <auto-generated/>\r\n")
                    .Add(Trivia(NullableDirectiveTrivia(Token(SyntaxKind.EnableKeyword), true)))
                    .Add(Trivia(PragmaWarningDirectiveTrivia(Token(SyntaxKind.DisableKeyword), true))));

        return SyntaxTree(complicationUnit.NormalizeWhitespace()).ToString();
    }

    private MemberDeclarationSyntax[] GenerateContent(Compilation compilation, INamedTypeSymbol classSymbol, ICollection<PropertyTuple> properties)
    {
        var members = new List<MemberDeclarationSyntax>();

        var constructorStatements = new List<StatementSyntax>();

        foreach (var (propertySymbol, _) in properties)
        {
            var attribute = propertySymbol.GetAttributes().First(a => a.AttributeClass?.ToDisplayString() == NotifyPropertyChangedWhenAttributeFullName);
            var eventName = attribute.ConstructorArguments[0].Value as string;

            if (string.IsNullOrEmpty(eventName)) continue;

            var propertyName = propertySymbol.Name;
            var propertyType = propertySymbol.Type;
            var handlerMethodName = $"On{propertyName}{eventName}";

            // 1. 创建事件处理器方法
            var handlerMethod = MethodDeclaration(PredefinedType(Token(SyntaxKind.VoidKeyword)), handlerMethodName)
                .AddModifiers(Token(SyntaxKind.PrivateKeyword))
                .AddParameterListParameters(
                    Parameter(Identifier("sender")).WithType(NullableType(PredefinedType(Token(SyntaxKind.ObjectKeyword)))),
                    Parameter(Identifier("e")).WithType(IdentifierName("global::System.EventArgs")))
                .WithBody(Block(
                    ExpressionStatement(
                        InvocationExpression(IdentifierName("OnPropertyChanged"))
                        .WithArgumentList(ArgumentList(SingletonSeparatedList(
                            Argument(InvocationExpression(IdentifierName("nameof"))
                                .WithArgumentList(ArgumentList(SingletonSeparatedList(
                                    Argument(IdentifierName(propertyName))))))))))
                ));
            members.Add(handlerMethod);

            // 2. 创建 On<PropertyName>Changed 分部方法
            var onChangedMethod = MethodDeclaration(PredefinedType(Token(SyntaxKind.VoidKeyword)), $"On{propertyName}Changed")
                .AddModifiers(Token(SyntaxKind.PartialKeyword))
                .AddParameterListParameters(
                    Parameter(Identifier("oldValue")).WithType(IdentifierName(propertyType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))),
                    Parameter(Identifier("newValue")).WithType(IdentifierName(propertyType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))))
                .WithBody(Block(
                    ExpressionStatement(
                        AssignmentExpression(SyntaxKind.SimpleAssignmentExpression,
                            MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, IdentifierName("oldValue"), IdentifierName(eventName)),
                            Token(SyntaxKind.MinusEqualsToken),
                            IdentifierName(handlerMethodName))),
                    ExpressionStatement(
                        AssignmentExpression(SyntaxKind.SimpleAssignmentExpression,
                            MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, IdentifierName("newValue"), IdentifierName(eventName)),
                            Token(SyntaxKind.PlusEqualsToken),
                            IdentifierName(handlerMethodName)))
                ));
            members.Add(onChangedMethod);

            // 3. 为构造函数添加事件订阅语句
            constructorStatements.Add(
                ExpressionStatement(
                    AssignmentExpression(SyntaxKind.SimpleAssignmentExpression,
                        MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, IdentifierName(propertyName), IdentifierName(eventName)),
                        Token(SyntaxKind.PlusEqualsToken),
                        IdentifierName(handlerMethodName)))
            );
        }

        if (constructorStatements.Any())
        {
            var constructor = ConstructorDeclaration(Identifier(classSymbol.Name))
                .AddModifiers(Token(SyntaxKind.PublicKeyword))
                .WithBody(Block(constructorStatements));
            members.Insert(0, constructor);
        }

        return [.. members];
    }
}

internal static class IncrementalGeneratorInitializationContextExtensions
{
    /// <inheritdoc cref="SyntaxValueProvider.ForAttributeWithMetadataName"/>
    public static IncrementalValuesProvider<T> ForAttributeWithMetadataNameAndOptions<T>(
        this IncrementalGeneratorInitializationContext context,
        string fullyQualifiedMetadataName,
        Func<SyntaxNode, CancellationToken, bool> predicate,
        Func<GeneratorAttributeSyntaxContextWithOptions, CancellationToken, T> transform)
    {
        // Invoke 'ForAttributeWithMetadataName' normally, but just return the context directly
        var syntaxContext = context.SyntaxProvider.ForAttributeWithMetadataName(
            fullyQualifiedMetadataName,
            predicate,
            static (context, token) => context);

        // Do the same for the analyzer config options
        var configOptions = context.AnalyzerConfigOptionsProvider.Select(static (provider, token) => provider.GlobalOptions);

        // Merge the two and invoke the provided transform on these two values. Neither value
        // is equatable, meaning the pipeline will always re-run until this point. This is
        // intentional: we don't want any symbols or other expensive objects to be kept alive
        // across incremental steps, especially if they could cause entire compilations to be
        // rooted, which would significantly increase memory use and introduce more GC pauses.
        // In this specific case, flowing non equatable values in a pipeline is therefore fine.
        return syntaxContext.Combine(configOptions).Select((input, token) => transform(new GeneratorAttributeSyntaxContextWithOptions(input.Left, input.Right), token));
    }
}

internal readonly struct GeneratorAttributeSyntaxContextWithOptions(
    GeneratorAttributeSyntaxContext syntaxContext,
    AnalyzerConfigOptions globalOptions)
{
    /// <inheritdoc cref="GeneratorAttributeSyntaxContext.TargetNode"/>
    public SyntaxNode TargetNode { get; } = syntaxContext.TargetNode;

    /// <inheritdoc cref="GeneratorAttributeSyntaxContext.TargetSymbol"/>
    public ISymbol TargetSymbol { get; } = syntaxContext.TargetSymbol;

    /// <inheritdoc cref="GeneratorAttributeSyntaxContext.SemanticModel"/>
    public SemanticModel SemanticModel { get; } = syntaxContext.SemanticModel;

    /// <inheritdoc cref="GeneratorAttributeSyntaxContext.Attributes"/>
    public ImmutableArray<AttributeData> Attributes { get; } = syntaxContext.Attributes;

    /// <inheritdoc cref="AnalyzerConfigOptionsProvider.GlobalOptions"/>
    public AnalyzerConfigOptions GlobalOptions { get; } = globalOptions;
}
